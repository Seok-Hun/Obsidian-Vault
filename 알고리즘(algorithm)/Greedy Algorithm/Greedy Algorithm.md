# 개요
### 최적의 해를 구하는 알고리즘
### 매 선택마다 최적의 답을 선택해서 가장 적합한 결과를 도출한다.
- 100% 정확한 답을 도출하는 것이 아니라 문제에 대해 가장 적합한 답을 도출 및 참고해 효율적인 방안을 찾는데 유용
- 여러 경우 중 하나를 선택해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식이다.
	- 순간마다 하는 선택은 그 순간에 대해 지역적으로 최적이지만, 그 선택들을 수집하여 최종적인 해답을 만들 때 그것이 최적이라는 보장은 없다.
### 욕심쟁이 알고리즘, 탐욕적 알고리즘이라고도 한다.
---
# 특징
### 탐욕적 선택 : 현재 순간의 선택이 다음 단계나 미래에 영향을 주지 않는다.
### 가장 크거나 가장 작은 순서대로 기준을 제시해준다.
- 정렬(Sort) 알고리즘과 같이 적용시키는 경향이 있다.
### 최적의 부분적인 구조를 가진다.
- 즉, 부분적인 문제의 최적해를 구해 가장 적합한 해를 구하는 구조이다.
### 장단점
- **징잠**
	- 처리속도가 다른 알고리즘보다 빠르다.
- **단점**
	- 최적의 답을 선택해 산출해도 항상 보장되지는 않는다.
### 항상 최적의 결과를 도출하지는 않지만, 최적에 근사한 값을 빠르게 도출할 수 있다.
- 이러한 특징 때문에 탐욕적 알고리즘은 근사 알고리즘이라고 할 수 있다.
>[!note]
> ### 근사 알고리즘(Approximation Algorithm)
>- 어떤 최적화 문제에 대한 해의 근사값을 구하는 알고리즘
>- 최적의 답을 구할 수는 없지만, 비교적 빠른 시간에 계산이 가능하며 어느 정도 보장된 근사해 계산 가능

---
# 절차
### 1. 문제를 부분적으로 나눈다.
### 2. 나눠진 문제들로부터 가장 최적의 선택을 찾는다.
### 3. 선택된 해(답)을 수집하여 문제의 본질적인 최적의 답을 찾는다.
---
# 예시
### 거스름돈 문제
- 500원, 100원, 50원, 10원 등의 동전들이 있다고 가정한다.
- 고객의 지불에 대한 거스름돈 지불을 위해 N원을 지불해야 하는 상황이 발생했다.
	- N값이 5,300워닝라고 가정할 때 최소한의 동전 수를 구하여라
	- 부분적인 부분에서 가장 큰 단위인 500원을 지불하면 10개가 필요함. 그 다음 단위인 100원으로 3개가 필요하다
	- 따라서 필요한 최소 동전 개수는 13개
### 파이썬 구현

```python
# N값 설정
n = 533

# 개수변수 설정
lnCount = 0

# 몫 설정
lnQuotient = 0

# 동전종류 리스트 설정
lsCoin_type = [500, 100, 50, 10]

# 동전종류별로 N값이 될 동전 개수
for coin in lsCoin_type:
	lnQuotient = n//coin
	lnCount += lnQuotient
	n %= coin

print(lnCount)
```
### 추를 이용한 최수 무게 측정
- 추는 2, 1, 6, 7, 29, 4가 있다.
- 해당 추를 이용해 가장 최소의 무게를 측정한다.
### 파이썬 구현

```python
lnValue = 1

# 추 무게 리스트
lsWeights = [2,1,6,7,29,4]
# 리스트 오름차순 정렬
lsWeights.sort()

# 최소의 무게합 구하기
for weight in lsWeights:
	if lnValue < weight:
		break
	else:
		lnValue += weight

print(lnValue)
```
- 결과 : 21